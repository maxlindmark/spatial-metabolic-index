---
title: "Estimate metabolic index parameters"
author: "Max Lindmark"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
  df_print: paged
pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 12,
  fig.asp = 0.618,
  fig.align ='center'
)
```

# Intro
Fit models à la Essington (2022) to acquire metabolic index parameters from a mixed GLMM (glmmTMB), leveraging information from species with lots of experimental data. Save metabolic index params and export as csv.

## Load packages & source functions

```{r load libraries, message=FALSE, warning=TRUE}
# Load libraries, install if needed
library(tidyverse)
library(readxl)
library(tidylog)
library(RCurl)
library(devtools)
library(glmmTMB)
library(rMR)
library(RColorBrewer)
library(patchwork)

# Source code for plots
source_url("https://raw.githubusercontent.com/maxlindmark/spatial-metabolic-index/main/R/functions/map-plot.R")

theme_set(theme_plot())
```

# Intro
Here we estimate metabolic index parameters using glmmTMB to data compiled by Essington et al (2022) with experimental data from Baltic Sea species added. We do it in units partial pressure and mg/L.

```{r estimate metabolic index parameters using glmmTMB}
# https://github.com/fate-spatialindicators/SDM_O2/blob/master/code/estimate_mi_parameters.R

# Read data
o2 <- readr::read_delim("https://raw.githubusercontent.com/maxlindmark/spatial-metabolic-index/main/data/essington_pO2_extended.csv", delim = ";") %>% 
  dplyr::select(-comment)

unique(o2$source)

# Now we need to standardize units across experimental data
spc_list <- unique(o2$spc)

c_to_K <- function(x) x + 273.15

# TODO: check salinity units in Essington data, not sure it's correct + my values are in pp.thou
# Get the experimental data in po2
o2$po2 <- NA
for (i in 1:length(spc_list)) {
  
  spc_index <- which(o2$spc == spc_list[i])
  
  tmp_dat <- dplyr::filter(o2, spc == spc_list[i])
  
  tmp_dat$po2 <- DO.unit.convert(tmp_dat$lc50,
                                 DO.units.in = tmp_dat$units[1],
                                 DO.units.out = "PP", 
                                 bar.press = 1,
                                 bar.units.in = "atm",
                                 temp.C = tmp_dat$temp,
                                 bar.units.out = "kpa",
                                 salinity = tmp_dat$salinity[1],
                                 salinity.units = "uS")
  
  o2$po2[spc_index] <- tmp_dat$po2
  
}

# Get the experimental data in unit mg/L
o2$o2 <- NA

for (i in 1:length(spc_list)) {
  
  spc_index <- which(o2$spc == spc_list[i])
  
  tmp_dat <- dplyr::filter(o2, spc == spc_list[i])
  
  tmp_dat$o2 <- DO.unit.convert(tmp_dat$lc50,
                                DO.units.in = tmp_dat$units[1],
                                DO.units.out = "mg/L", 
                                bar.press = 1,
                                bar.units.in = "atm",
                                temp.C = tmp_dat$temp,
                                bar.units.out = "kpa",
                                salinity = tmp_dat$salinity[1],
                                salinity.units = "uS")
  
  o2$o2[spc_index] <- tmp_dat$o2
  
}

# Now convert to convert oxygen from mg/L -> ml/L -> micro mol/l
# 1 mg/l = 22.391 ml/31.998 = 0.700 ml/l 
# https://www.ices.dk/data/tools/Pages/Unit-conversions.aspx

o2$o2 <- ((o2$o2*0.7) * (10^3)) / 22.391

o2$spc <- as.factor(o2$spc)
nspc <- length(levels(o2$spc))

ggplot(o2, aes(po2, o2)) + 
  geom_point()

# Add Boltzmann-Arrhenius temperature
tref <- 15 # arbitrary reference temperature
kb <- 0.000086173324 # Boltsmann's constant in unit Ev
o2$inv_temp <- (1 / kb)  * ( 1 / (o2$temp + 273.15) - 1 / (tref + 273.15))

# Plot the data we want to fit
o2 %>% 
  ggplot(aes(inv_temp, -log(po2), color = spc)) + 
  geom_point() + 
  geom_smooth(aes(inv_temp, -log(po2)), method = "lm", inherit.aes = FALSE)

o2 %>% 
  ggplot(aes(inv_temp, -log(o2), color = spc)) + 
  geom_point() + 
  geom_smooth(aes(inv_temp, -log(o2)), method = "lm", inherit.aes = FALSE)

o2 %>% 
  filter(spc %in% c("AtlanticCod", "plaice", "dab")) %>% 
  ggplot(aes(log(b), log(po2), shape = ref, fill = spc, color = spc)) + 
  geom_point(size = 4) + 
  scale_shape_manual(values = c(21:24)) +
  scale_color_brewer(palette = "Dark2") + 
  scale_fill_brewer(palette = "Dark2") +
  theme(legend.position = c(0.85, 0.85))
```

The last plot illustrates the issue with cod. We know from regional experiments that Baltic cod have a higher critical oxygen, but if we use experiments by Plante using cod from the Western Atlantic, we will estimate them to be MORE oxygen tolerant than Baltic flatfishes. We don't have enough data to estimate both a random species intercept and a "reference" effect. So what I'll do is that I use the original Essington data to estimate the size and temperature dependence of (p)O2 crit, and then use those estimates to temperature-correct the Baltic experimental data (which anyway don't have mass or temperature variation, so removing them from the data set is a small loss.)

```{r}
o2_og <- o2 %>%
  filter(source == "Essington2022")

# Fit model to Eq.2 in Essington (2022). Fixed effects of mass and temperature
# oxygen in unit pp
fit_po2 <- glmmTMB(-log(po2) ~ (1|spc) + log(b) + inv_temp,
                   data = o2_og,
                   family = gaussian(link = "identity"))

summary(fit_po2)
res_po2 <- residuals(fit_po2)
qqnorm(res_po2); qqline(res_po2)

# oxygen in unit micro mol / L
fit_o2 <- glmmTMB(-log(o2) ~ (1|spc) + log(b) + inv_temp,
                  data = o2_og,
                  family = gaussian(link = "identity"))

summary(fit_o2)

res_o2 <- residuals(fit_o2)
qqnorm(res_o2)
qqline(res_o2)

# Now we can mass and temperature correct (p)O2 in Baltic experiments by using Essingtons Eq. 2., but re-arranging it so that we have log(Ao) on the LHS. I.e., by assuming that phi = 1 is equal to critical o2, and we have data for critical o2, we can calculate Ao from the other parameters
fe_o2 <- tibble(term = names(fixef(fit_o2)$cond),
                est = fixef(fit_o2)$cond) %>% 
  filter(term %in% c("log(b)", "inv_temp")) %>% 
  pivot_wider(names_from = "term", values_from = est) %>% 
  rename(n_o2 = `log(b)`,
         E_o2 = inv_temp)

fe_po2 <- tibble(term = names(fixef(fit_po2)$cond),
             est = fixef(fit_po2)$cond) %>% 
  filter(term %in% c("log(b)", "inv_temp")) %>% 
  pivot_wider(names_from = "term", values_from = est) %>% 
  rename(n_po2 = `log(b)`,
         E_po2 = inv_temp)

o2_new <- o2 %>%
  filter(source == "Lindmark") %>% 
  dplyr::select(spc, b, inv_temp, temp, po2, o2)

o2_new <- o2_new %>% 
  mutate(A0_o2 = exp(-fe_o2$E_o2*inv_temp - log(o2) -fe_o2$n_o2*log(b)),
         A0_po2 = exp(-fe_po2$E_po2*inv_temp - log(po2) -fe_po2$n_po2*log(b)))

o2_new

# Check if correct (if we can recreate the random intercepts using this manual correction)
re_po2 <- data.frame(spc = row.names(ranef(fit_po2)$cond$spc), 
                     est = ranef(fit_po2)$cond$spc$`(Intercept)`) %>% 
  mutate(A0_po2 = exp(fixef(fit_po2)$cond[1] + est))

o2_og <- o2_og %>% 
  mutate(A0_po2 = exp(-fe_po2$E_po2*inv_temp - log(po2) - fe_po2$n_po2*log(b)))

ggplot(o2_og, aes(spc, A0_po2, color = "manual mass and temp normalization")) + 
  geom_jitter(height = 0, width = 0.1, size = 2) +
  geom_point(data = re_po2, aes(spc, A0_po2, color = "random intercept"), size = 2) + 
  geom_point(data = o2_new, aes(spc, A0_po2, color = "baltic species"), size = 2) + 
  scale_color_brewer(palette = "Set2")

# Now do concentration...
re_o2 <- data.frame(spc = row.names(ranef(fit_o2)$cond$spc), 
                    est = ranef(fit_o2)$cond$spc$`(Intercept)`) %>% 
  mutate(A0_o2 = exp(fixef(fit_o2)$cond[1] + est))

o2_og <- o2_og %>% 
  mutate(A0_o2 = exp(-fe_o2$E_o2*inv_temp - log(o2) - fe_o2$n_o2*log(b)))

ggplot(o2_og, aes(spc, A0_o2, color = "manual mass and temp normalization")) + 
  geom_jitter(height = 0, width = 0.1, size = 2) +
  geom_point(data = re_o2, aes(spc, A0_o2, color = "random intercept"), size = 2) + 
  geom_point(data = o2_new, aes(spc, A0_o2, color = "baltic species"), size = 2) + 
  scale_color_brewer(palette = "Set2")

# Looks good... Now we can save this dataframe and load it when we need to calculate mi in the data.
mi_params <- o2_new %>%
  dplyr::select(-b, -inv_temp, po2, o2) %>% 
  mutate(n_po2 = fe_po2$n_po2,
         E_po2 = fe_po2$E_po2,
         n_o2 = fe_o2$n_o2,
         E_o2 = fe_o2$E_o2) %>% 
  rename(species = spc) %>% 
  mutate(species = ifelse(species == "AtlanticCod", "cod", as.character(species)))

mi_params

write.csv(mi_params, "data/clean/mi_params.csv")
```

# Plot the metabolic index over size

```{r}
pal <- brewer.pal(name = "Dark2", n = 8)

# Read size csv to calculate the metabolic index
sizes <- readr::read_csv("https://raw.githubusercontent.com/maxlindmark/spatial-metabolic-index/main/data/clean/sizes.csv") %>% 
  mutate(group = paste(species, name, sep = "_"))

sizes

# Make a df from min to mat and max size
nd <- data.frame(species = rep(sizes$species, each = 50)) %>% 
  mutate(b = NA, 
         b = ifelse(species == "cod", seq(1, filter(sizes, species == "cod")$mat_w[1], length.out = 50), b),
         b = ifelse(species == "dab", seq(1, filter(sizes, species == "dab")$mat_w[1], length.out = 50), b),
         b = ifelse(species == "flounder", seq(1, filter(sizes, species == "flounder")$mat_w[1], length.out = 50), b),
         b = ifelse(species == "plaice", seq(1, filter(sizes, species == "plaice")$mat_w[1], length.out = 50), b)) %>% 
  left_join(mi_params) %>% 
  mutate(phi = A0_o2*b^n_o2) %>% # Calculate metabolic index over size for each species at T_ref at o2 = 1
  mutate(species = str_to_title(species))

p1 <- ggplot(nd, aes(b, phi, color = species)) + 
  scale_color_manual(values = rev(pal)) +
  geom_line() +
  labs(y = "Metabolic index (\u03C6)", x = "Body mass (g)", color = "") +
  theme_plot() +
  guides(color = "none") +
  theme(aspect.ratio = 1,
        legend.direction = "vertical",
        legend.position = c(0.9, 0.9),
        legend.background = element_rect(fill = NA),
        legend.spacing.y = unit(0, 'cm'),
        legend.text = element_text(size = 7),
        legend.title = element_text(size = 7))

# Now do for maturation size at a range of temperatures (fixed o2...)
nd2 <- data.frame(expand.grid(species = rep(sizes$species, each = 50),
                              temp = seq(10, 20, 0.2))) %>% 
  mutate(inv_temp = (1 / kb)  * ( 1 / (temp + 273.15) - 1 / (tref + 273.15))) %>% 
  left_join(sizes) %>% 
  left_join(mi_params %>% dplyr::select(-temp), by = "species") %>% 
  mutate(phi = (A0_o2*mat_w^n_o2) * exp(E_o2 * inv_temp)) %>% # Calculate metabolic index over size for each species at T_ref at o2 = 1
  mutate(species = str_to_title(species))

p2 <- ggplot(nd2, aes(temp, phi, color = species)) + 
  scale_color_manual(values = rev(pal)) +
  geom_line() +
  labs(y = "", x = "Temperature (°C)", color = "") +
  theme_plot() +
  theme(aspect.ratio = 1,
        legend.direction = "vertical",
        legend.background = element_rect(fill = NA),
        legend.position = c(0.85, 0.9),
        legend.spacing.y = unit(0, 'cm'),
        legend.text = element_text(size = 7),
        legend.title = element_text(size = 7))

p1 + p2

## Make the same plot but now with flounder getting plaice parameters...
# Make a df from min to mat and max size
mi_pars2 <- mi_pars
mi_pars2[4, c(4:5)] <- mi_pars2[1, c(4:5)]

nd <- data.frame(species = rep(sizes$species, each = 50)) %>% 
  mutate(b = NA, 
         b = ifelse(species == "cod", seq(1, filter(sizes, species == "cod")$mat_w[1], length.out = 50), b),
         b = ifelse(species == "dab", seq(1, filter(sizes, species == "dab")$mat_w[1], length.out = 50), b),
         b = ifelse(species == "flounder", seq(1, filter(sizes, species == "flounder")$mat_w[1], length.out = 50), b),
         b = ifelse(species == "plaice", seq(1, filter(sizes, species == "plaice")$mat_w[1], length.out = 50), b)) %>% 
  left_join(mi_pars2) %>% 
  mutate(phi = A0_o2*b^n_o2) %>% # Calculate metabolic index over size for each species at T_ref at o2 = 1
  mutate(species = str_to_title(species))

p1 <- ggplot(nd, aes(b, phi, color = species, linetype = species)) + 
  scale_color_manual(values = rev(pal)) +
  geom_line(size = 0.9) +
  labs(y = "Metabolic index (\u03C6)", x = "Body mass (g)", color = "") +
  theme_plot() +
  guides(color = "none", linetype = "none") +
  theme(aspect.ratio = 1,
        legend.direction = "vertical",
        legend.position = c(0.9, 0.9),
        legend.background = element_rect(fill = NA),
        legend.spacing.y = unit(0, 'cm'),
        legend.text = element_text(size = 7),
        legend.title = element_text(size = 7))

# Now do for maturation size at a range of temperatures (fixed o2...)
nd2 <- data.frame(expand.grid(species = rep(sizes$species, each = 50),
                              temp = seq(10, 20, 0.2))) %>% 
  mutate(inv_temp = (1 / kb)  * ( 1 / (temp + 273.15) - 1 / (tref + 273.15))) %>% 
  left_join(sizes) %>% 
  left_join(mi_pars2, by = "species") %>% 
  mutate(phi = (A0_o2*mat_w^n_o2) * exp(E_o2 * inv_temp)) %>% # Calculate metabolic index over size for each species at T_ref at o2 = 1
  mutate(species = str_to_title(species))

p2 <- ggplot(nd2, aes(temp, phi, color = species, linetype = species)) + 
  scale_color_manual(values = rev(pal)) +
  geom_line(size = 0.9) +
  labs(y = "", x = "Temperature (°C)", color = "") +
  guides(linetype = "none") + 
  theme_plot() +
  theme(aspect.ratio = 1,
        legend.direction = "vertical",
        legend.background = element_rect(fill = NA),
        legend.position = c(0.85, 0.9),
        legend.spacing.y = unit(0, 'cm'),
        legend.text = element_text(size = 7),
        legend.title = element_text(size = 7))

p1 + p2

ggsave("figures/mi_mass_temp.pdf", width = 17, height = 17, units = "cm", device = cairo_pdf)


# And lastly for the same size (10g)
nd3 <- data.frame(expand.grid(species = rep(sizes$species, each = 50),
                              temp = seq(10, 20, 0.2))) %>% 
  mutate(inv_temp = (1 / kb)  * ( 1 / (temp + 273.15) - 1 / (tref + 273.15)),
         b = 10) %>% 
  left_join(mi_params %>% dplyr::select(-temp), by = "species") %>% 
  mutate(phi = (A0_o2*b^n_o2) * exp(E_o2 * inv_temp)) # Calculate metabolic index over size for each species at T_ref at o2 = 1

# Sdd winter flounder to compare? the reason is a question whether we should use flounder data because the sizes are extremely small and when we correct we find that flounder has the lowest phi of all, when in reality it's likely most tolerant to to low oxygen and temperature. We probably should expect it to be closer to plaice or winter flounder. If we use experimental data for dab, plaice and cod they all come from the same experiment, and that's a bonus... 
wflounder <- data.frame(expand.grid(species = rep("winter_flounder", each = 50),
                              temp = seq(10, 20, 0.2))) %>% 
  mutate(inv_temp = (1 / kb)  * ( 1 / (temp + 273.15) - 1 / (tref + 273.15)),
         b = 10) %>% 
  mutate(phi = (filter(re_o2, spc == "wflounder")$A0_o2*b^mi_params$n_o2[1]) * exp(mi_params$E_o2[1] * inv_temp))

nd4 <- bind_rows(nd3, wflounder)

ggplot(nd4, aes(temp, phi, color = species)) + 
  scale_color_brewer(palette = "Set1") +
  geom_line()
```

